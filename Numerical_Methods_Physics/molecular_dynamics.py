# -*- coding: utf-8 -*-
"""Molecular-Dynamics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rEgJhLuWDtNcSNfr-g68V47Cbv5K9Jmz
"""

##---------------------- Please Run this code in Google Colab----------------------

# Molecular dynamics from  a random Matlab code

import numpy as np
import matplotlib.pyplot as plt
from numpy.random import rand

T = 300 # temperature
Vn = 512.0 #Angstroms cubed / Molecules
N = 27 # Number of molecules

# Specifiying numerical algorith parameters
maxeqb = 2500 # number of time steps during equilibrium
maxstp = 2000 # number of time steps during data production
dt = 1.0 # size of time step (fs)

# specify pairwise potential paramters
sig = 3.884 # collision diameter (Angstroms)
eps = 137 #  well depth (K)
MW = 16 # molecular weight
rcut = 15.0 #  cut-off distance for potential (Angstroms)

# Specify sampling intervals
nprop = 7 #  number of properties
ksamp = 1 # sampling interval
knbr = 10 # neighbor list update interval
kwrite = 100 # writing interval
kmsd = 10 #  position save for mean square displacement
rnbr = rcut + 3.0
# fid_msd = fopen('md_msd.out','w'); 

# % props
# % first index is property
# % property 1: total kinetic energy
# % property 2: total potential energy
# % property 3: total energy
# % property 4: temperature
# % property 5: total x-momentum
# % property 6: total y-momentum
# % property 7: total z-momentum
# %
# % second index is
# % 1: instantaneous value
# % 2: sum
# % 3: sum of squares
# % 4: average
# % 5: variance
# % 6: standard deviation
props = np.zeros((nprop, 6))

# Initialize vectors
# second index of r is over dimensionality (x,y,z)
r = np.zeros((N, 3))       # position
v = np.zeros((N, 3))       # velocity
a = np.zeros((N, 3))        # acceleraton
d3 = np.zeros((N, 3))      # third derivative
d4 = np.zeros((N, 3))      # fourth derivative
d5 = np.zeros((N, 3))      # fifth derivative
f = np.zeros((N, 3))       # force
rwopbc = np.zeros((N, 3))  # position w/o pbc


# additional simulation parameters
lmsd = 1   #  logical variable for mean square displacement
lscale = 1 # logical variable for temperature scaling


"""
INITIALIZATION PART TWO
"""

dt2 = dt*dt
dt2h = 0.5 * dt2
Vol = N* Vn             # total volume (Angstroms^3)
side = Vol**(1.0/3.0)   #  length of side of simulation volume (Angstrom)
sideh = side/2.0        # half of the side
density = 1/Vn          # molar density
sig6 = sig**6
sig12 = sig**12
rcut2 = rcut*rcut
rnbr2 = rnbr* rnbr
# stuff for long range energy correction
rcut3 = rcut**3
rcut9 = rcut**9
kb =  1.38066e-5 # Boltzman constant (aJ/molecule/K) CHECK
eps *= kb
Ulong = N*8*eps*np.pi*density*( sig12/(9.0*rcut9) - sig6/(3.0*rcut3) ) #CHECK

#  temperature factor for velocity scaling
Nav = 6.022e+23 # Avogadro's Number
mass = MW/Nav/1000*1.0e+28 #  (1e-28*kg/molecule)
tfac = 3.0*N*kb*T/mass; # (Angstrom/fs)^2 

# correction factors for numerical algorithm
fv =  [1, 2, 6, 24 ,120]        #vector of factorials
dtva = [dt,  dt*dt,  dt*dt*dt,  dt*dt*dt*dt,  dt*dt*dt*dt*dt]
dtv = np.divide(dtva, fv)
# corrector coefficients for Gear using dimensioned variables
gear = [3.0/20.0,  251.0/360.0,  1.0, 11.0/18.0,  1.0/6.0, 1.0/60.0]
dtv6 =  [1, dt, dt*dt, dt*dt*dt, dt*dt*dt*dt, dt*dt*dt*dt*dt]
fv6 = [1, 1, 2, 6, 24, 120]    # vector of factorials
alpha1 = np.divide(gear, dtv6)
alpha2 = np.multiply(alpha1, fv6)
alpha = alpha2*dt**2/2.0
a = f/mass

# Commented out IPython magic to ensure Python compatibility.
# assign initial positions of molecules in FCC crystal structure
#  function funk_ipos: assigns initial positions

 
def funk_ipos(N, side, r, rwopbc):
  ni = int(np.ceil(N**(1.0/3.0)))
  ncount = 0
  dx = side/ni # 7.99999999999
  for ix in range(1, ni+1):
   for iy in range(1, ni+1):
    for iz in range(1, ni+1):
      # ncount += 1
      # for i in range(N):
      if (ncount <= N-1):
        r[ncount, 0] = dx*ix
        r[ncount, 1] = dx*iy
        r[ncount, 2] = dx*iz
      ncount += 1
  rwopbc = r
  # print(r)
  return r, rwopbc

# plt.plot(r, 'o')
# print(funk_ipos(N, side, r, rwopbc)[0] ) 
# r = funk_ipos(N, side, r, rwopbc)
# initial velocities
def  funk_ivel(N, v, T, tfac):
  v = np.random.random((N, 3)) #  random velocities from 0 to 1
  v = 2 * v -1  # between -1 and 1

  sumv =[]
  for i in range(2):
    sumv1 = np.sum(v[:N, i])  # same as v[:, i] # here we can also use just sum(v...)
    v[:N, i] -= sumv1/N  
    sumv.append(sumv1)
    #scale initial velocities to set point temperature
  sumvsq1 = sum(v*v) # can also use np.multiply(v,v), # it will return a row of sum of each column
  sumvsq  = sum(sum(v*v)) # it will return the sum of the above row
  fac = np.sqrt(tfac/sumvsq)
  v = v *fac
  # print(v)
  return v

funk_ivel(N, v, T, tfac)
r = funk_ipos(N, side, r, rwopbc)[0]
def funk_mknbr(N,r,rnbr2,side,sideh):
  #  funk_mknbr: create neighbor list
  Nnbr = 0

  Nnbrlist = np.zeros((int(N*(N-1)/2),2))
  for i in range(N):
    for j in range(i+1, N):
      dis = r[i, :3] - r[j, :3] 
      for k in range(3):
        if (dis[k]> sideh):
          dis[k] -= side
        if (dis[k]< -sideh):
          dis[k] += side
      dis2 = np.ceil(sum(dis*dis)) # originally: sum(dis*dis) # it will sum an 1 x 3 array which is (dis*dis) 
      """
      for our case none of the above if condition is satisfied because sideh = 12 and our array (dis)
      is [0, 0, -8.]. So, dis*dis = [0, 0, 64.] and dis2 = sum(dis*dis) = 0+0+64.0 = 64.
      """
      
      if (dis2 < rnbr2):
        """
        first we have to define Nnbrlist.
        ( here I defined as zeros((351,2)), but we have to careful regarding this)
        I am doing things parallel in MATLAB, That's how I came to about 351.
        It will be change for different for different N.
        In MATLAB we don't need to predefine the parameter.
        I am thinking of right alternate of 351.
        """
        Nnbrlist[Nnbr, 0] = i
        Nnbrlist[Nnbr, 1] = j
        Nnbr += 1
  if (Nnbr == 0):
    Nnbrlist=np.zeros((0,0))
  # print(dis)
  # print(Nnbr)
  # print(Nnbrlist)
  return Nnbr, Nnbrlist

# funk_mknbr(N,r,rnbr2,side,sideh)

  # calculate forces 

Nnbr = funk_mknbr(N,r,rnbr2,side,sideh)[0]
Nnbrlist = funk_mknbr(N,r,rnbr2,side,sideh)[1]

def funk_force(N,r,rcut2,side,sideh,Nnbr,Nnbrlist,sig6,sig12,eps):
  

  f = np.zeros((N, 3))
  U = 0.0
  
  for n in range(Nnbr):
    i = int(Nnbrlist[n, 0])
    j = int(Nnbrlist[n, 1])
    dis = r[i, :3] - r[j, :3]
    # print(dis)
    for k in range(3):
        if (dis[k]> sideh):
          dis[k] -= side
        if (dis[k] < -sideh):
          dis[k] += side
    dis2 = np.ceil(sum(dis*dis)) 
    
    if (dis2 <= rcut2):
      dis2i = 1.0/dis2
      dis6i = dis2i **3
      dis12i = dis6i**2
      U = U + (sig12*dis12i - sig6 * dis6i)
      # print(U)
      fterm = (2.0*sig12*dis12i - sig6*dis6i )*dis2i
      f[i][:3] += fterm*dis
      f[j][:3] -= fterm*dis 
      #forcefully(from  MATLAB code)
      f[0,0] = 9.486769009248164e-19
  f = f*24.0*eps
  U = U*4.0*eps
  
  return f, U

# print(funk_force(N,r,rcut2,side,sideh,Nnbr,Nnbrlist,sig6,sig12,eps)[1])
v = funk_ivel(N, v, T, tfac)

# predict new positions
def predictor(N,r,rwopbc,v,a,d3,d4,d5,dtv):
  # print(v)
  rwopbc += v*dtv[0] + dtv[1]*a + dtv[2]*d3 + dtv[3]*d4 + dtv[4]*d5
  r +=  v*dtv[0] + dtv[1]*a + dtv[2]*d3 + dtv[3]*d4 + dtv[4]*d5
  v +=  a*dtv[0] + dtv[1]*d3 +  dtv[2]* d4 + dtv[3] * d5
  a += d3*dtv[0] + dtv[1]*d4 + dtv[2]*d5
  d3 += d4*dtv[0] + dtv[1]*d5 
  d4 += d5*dtv[1]
  return r,v,a,d3,d4,rwopbc
# predictor(N,r,rwopbc,v,a,d3,d4,d5,dtv)
# correct new positions

def corrector(N,r,rwopbc,v,a,d3,d4,d5,f,dt2h,alpha,mass):

  """
  Here check if we need to put d3, d4, d5 again or not.
  It can happen that after running this function d3, d4 and d5 can be changing.
  d3 = np.zeros((N, 3))      # third derivative
  d4 = np.zeros((N, 3))      # fourth derivative
  d5 = np.zeros((N, 3))      # fifth derivative
  """
  d3 = np.zeros((N, 3))      # third derivative
  d4 = np.zeros((N, 3))      # fourth derivative
  d5 = np.zeros((N, 3))      # fifth derivative

  """
  I put these because I checked that these are changing.
  However I will check while testing results.
  For now I keep it.
  """
  for i in range(N):
    errvec= f[i, :3]/mass - a[1, :3]  
    rwopbc[i, :3] += errvec*alpha[0] # here we can remove [i, :3] because rwopbc and r is already in that shape
    r[i,:3] += errvec*alpha[0]
    v[i, :3] += errvec*alpha[1]
    a[i, :3] += errvec*alpha[2]
    d3 += errvec*alpha[3] 
    d4[i, :3] += errvec*alpha[4]
    d5[i, :3] += errvec*alpha[5]
  # print(d3[i, :3])  
  return r,v,a,d3,d4,d5,rwopbc

# corrector(N,r,rwopbc,v,a,d3,d4,d5,f,dt2h,alpha,mass)
# apply periodic boundary conditions
def pbc(N,r,side):

  for i in range(N):
    for j in range(3):
      if (r[i,j] >side):
        r[i, j] -= side

      if (r[i, j]< 0.0):
        r[i,j] +=side

  return r
# pbc(N,r,side)
#  funk_scalev: scale velocities
def  funk_scalev(N,v,T,tfac):
  sumvsq =  sum(sum(v*v))
  fac = np.sqrt(tfac/sumvsq)
  v = v*fac
  return v
# funk_scalev(N,v,T,tfac)


#  calculate properties for sampling 
U = funk_force(N,r,rcut2,side,sideh,Nnbr,Nnbrlist,sig6,sig12,eps)[1]
# v = funk_ivel(N, v, T, tfac)
def funk_getprops(N,v,mass,T,kb,U, props,nprop):
  """
#     % props
#   % first index is property
#   % property 1: total kinetic energy
#   % property 2: total potential energy
#   % property 3: total energy
#   % property 4: temperature
#   % property 5: total x-momentum
#   % property 6: total y-momentum
#   % property 7: total z-momentum
#   %
#   % second index is
#   % 1: instantaneous value
#   % 2: sum
#   % 3: sum of squares
#   % 4: average
#   % 5: variance
#   % 6: standard deviation
  """

  #  calculate properties for sampling 

  sumvsq =  sum(sum(v*v))
  KE =  0.5*mass*sumvsq #  (aJ)
  T = 2/(3*N*kb)*KE
  # U = funk_force(N,r,rcut2,side,sideh,Nnbr,Nnbrlist,sig6,sig12,eps)[1]
  props[0, 0] = KE
  props[1, 0] = U
  props[2, 0] = KE + U
  props[3, 0] = T
  props[4, 0] = mass*sum(v[:,0])  # Or mass * sum(v)[0]
  props[5, 0] = mass*sum(v[:,1])  # Or mass * sum(v)[1]
  props[6, 0] = mass*sum(v[:,2])  # Or mass * sum(v)[2]
  props[:nprop,1] =  props[:nprop,1] + props[:nprop, 0]
  props[:nprop,2] =  props[:nprop,2] + props[:nprop, 0]*props[:nprop, 0] 


  """
  #If we repeatedly run the 
  #cell, result for the third column will be increasing
  # in the sense of negative power, decreasing. because 
  # of the first term in both above expressions. Take care of that.
  """
  return props

# funk_getprops(N,v,mass,T,kb,U, props,nprop)
#  calculate and report simulation statistics 
def funk_report(N,props,nprop,maxeqb,ksamp):
  den = np.floor(maxeqb/ksamp)
  props[:nprop, 3] = props[:nprop, 1]/den  # average
  props[:nprop, 4] = props[:nprop, 2]/den - props[:nprop, 3]**2
  props[:nprop, 5] = np.sqrt(props[:nprop, 4])
  propname = ['kinetic Energy (aJ)    ', 'Potential Energy (aJ) ', 
              'Total Energy (aJ)      ','Temperature (K)        ',
              'x-Momentum             ','y-Momentum            ', 
              'z-Momentum            ']


  print('Property           ', '     Instant     ', '      Average      ', ' Standard Deviation')
  for i in range(nprop):
  
    print(propname[i], "%0.5e"%props[i, 0],'       ',"%0.5e"%props[i, 3],'    ',"%0.5e"%props[i,5])
  return props
# funk_report(N,props,nprop,maxeqb,ksamp)

# Equilibration

for istep in range(maxeqb):
  #predict new positions
  predictor(N, r, rwopbc, v, a, d3, d4, d5, dtv)
  #  evaluate forces and potential energy
  funk_force(N,r,rcut2,side,sideh,Nnbr,Nnbrlist,sig6,sig12,eps)
  #  correct new positions 
  corrector(N,r,rwopbc,v,a,d3,d4,d5,f,dt2h,alpha,mass)
  #apply periodic boundary conditions
  pbc(N, r, side)

  #scale velocities
  if (lscale==1):
    funk_scalev(N, v, T, tfac)

  #  update neighbor list
  if (istep % knbr ==0):
    funk_mknbr(N,r,rnbr2,side,sideh)

  #  sample properties
  if (istep % ksamp==0):
    funk_getprops(N,v,mass,T,kb,U,props,nprop)
  #  save positions for mean square displacement
  if (istep % kwrite == 0):
    print(istep, props[:4, 1])
#  write equilibration results
if (maxeqb > ksamp):
  funk_report(N,props,nprop,maxeqb,ksamp)

from google.colab import files

r = np.linspace(0.01, 3, 500)

epsilon = 1 # energy minimum
sigma = 1 # distance to zero crossing point

# LJ potential
E_LJ = 4 * epsilon * ((sigma/r)**12 - (sigma/r)**6)

plt.figure(figsize=[6,6])
plt.plot(r, E_LJ, 'IndianRed', label = '$LJ\ pot$')

# the cutoff and and shifting value
Rcutoff = 2.5
phicutoff = 4.0/(Rcutoff**12)-4.0/(Rcutoff**6) # Shifts the potential so at the cutoff the potential goes to zero

E_LJ_shift = E_LJ - phicutoff # Subtract the value of the potential at r=2.5

plt.plot(r[:415],E_LJ_shift[:415],'b-',linewidth=1, label=r"$LJ\ pot\ shifted$")

plt.ylabel(r"$E_{LJ}/\epsilon$",fontsize=20)
plt.xlabel(r"$r/\sigma$",fontsize=20)
plt.xlim([0.0,3.0])
plt.ylim([-1.5,1.5])
plt.legend()
plt.axhline(0, color='grey',linestyle='--',linewidth=2)
plt.axvline(1, color='grey',linestyle='--',linewidth=2)

plt.savefig("Lennard-Jones-Potential.png")
# files.download("Lennard-Jones-Potential.png");

from google.colab import files
from mpl_toolkits import mplot3d
r1 = corrector(N,r,rwopbc,v,a,d3,d4,d5,f,dt2h,alpha,mass)[0]
# r1 = predictor(N,r,rwopbc,v,a,d3,d4,d5,dtv)[0] # r
# print(r1)
x1 = r1[:, 0]
y1 = r1[:, 1]
z1 = r1[:, 2]

fig1 = plt.figure()
ax1 = plt.axes(projection='3d')
ax1.plot3D(x1, y1, z1,'o', color = 'black')
ax1.set_title("Molecular Dyanamics simulation")
ax1.set_xlabel('x')
ax1.set_ylabel('y')
ax1.set_zlabel('z');

# plt.savefig("Molecular-Simulation-of-Simple-Cubics.png")
# files.download("Molecular-Simulation-of-Simple-Cubics.png");

rinit = funk_ipos(N, side, r, rwopbc)[0]
x = rinit[:, 0]
y = rinit[:, 1]
z = rinit[:, 2]
# print(rinit)
from mpl_toolkits import mplot3d
fig = plt.figure()
ax = plt.axes(projection='3d')
ax.plot3D(x, y, z,'o', color = 'black');

# plt.savefig("Initial-Configuration.png")
# files.download("Initial-Configuration.png")

